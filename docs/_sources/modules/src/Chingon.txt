.. default-domain:: chpl

.. module:: Chingon
   :synopsis: Documentation for Chingon v 0.1.1

Chingon
=======
**Usage**

.. code-block:: chapel

   use Chingon;


Documentation for Chingon v 0.1.1
=================================

Much of this library is motivated by the book `Graph Algorithms in the Language of Linear Algebra by Kepner and Gilbert <http://bookstore.siam.org/se22/>`_

Some basic definitions.  We are attempting to operate according to general standards.  Since some of
the literature is inconsistent, we define some important concepts here.

*  A: The Adjacency matrix, A(i,j) is the weight between vertices i and j.  A(i,i) = 0.
   In the case of directed matrices, the edge represents the weight or indicator of i to j.
*  W: The weight matrix, W(i,j) is the weight between vertices i and j and may have non-zero diagonal
*  Laplacian Matrix L = D - A for simple graphs: https://en.wikipedia.org/wiki/Laplacian_matrix#Laplacian_matrix_for_simple_graphs

An "edge" exists between two vertices, the terminology being "from the tail to the head".


.. class:: Graph

   
   A Graph object is a (sparse) matrix with some meta-data attached to it.  The underlying
   matrix
   


   .. attribute:: var vdom: domain(2)

   .. attribute:: var SD: vdom.defaultSparseDistchpl__buildSparseDomainRuntimeTypevdom dmapped CS(compressRows = true)

   .. attribute:: var W: [SD] real

   .. attribute:: var name: string

   .. attribute:: var vnames: domain(string)

   .. attribute:: var vids: [vnames] int

   .. attribute:: var nameIndex: [1..0] string

   .. attribute:: var directed: bool = false

   .. method:: proc init(W: [])

      
      Example object initialization::
      
        var nv: int = 8,
            D: domain(2) = {1..nv, 1..nv},
            SD: sparse subdomain(D),
            M: [SD] real;
      
          SD += (1,2); W[1,2] = 1;
          SD += (1,3); W[1,3] = 1;
          SD += (1,4); W[1,4] = 1;
          SD += (2,2); W[2,2] = 1;
          SD += (2,4); W[2,4] = 1;
          SD += (3,4); W[3,4] = 1;
          SD += (4,5); W[4,5] = 1;
          SD += (5,6); W[5,6] = 1;
          SD += (6,7); W[6,7] = 1;
          SD += (6,8); W[6,8] = 1;
          SD += (7,8); W[7,8] = 1;
        var g3 = new Graph(M=M, name="Vato", vnames = vn);
      
         In ascii, the graph is
      
      ::
      
        (3)--(1)--(2)> (a loop)
         |    |    |
         |    |    |
         ----(4)----
              |
              |--(5)--(6)--(7)--(8)  // TURN TURN KICK TURN!  Bob Fosse Lives!
                       |---------|
      
      The Weighted Matrix (assuming undirected) is thus
      
      ::
      
        1) star lord: 0 1 1 1 0 0 0 0
        2)    gamora: 0 1 0 1 0 0 0 0
        3)     groot: 0 0 0 1 0 0 0 0
        4)      drax: 0 0 0 0 1 0 0 0
        5)    rocket: 0 0 0 0 0 1 0 0
        6)    mantis: 0 0 0 0 0 0 1 1
        7)     yondu: 0 0 0 0 0 0 0 1
        8)    nebula: 0 0 0 0 0 0 0 0
      
      With symmetric version
      
      ::
      
        1) star lord: 0 1 1 1 0 0 0 0
        2)    gamora: 1 1 0 1 0 0 0 0
        3)     groot: 1 0 0 1 0 0 0 0
        4)      drax: 1 1 1 0 1 0 0 0
        5)    rocket: 0 0 0 1 0 1 0 0
        6)    mantis: 0 0 0 0 1 0 1 1
        7)     yondu: 0 0 0 0 0 1 0 1
        8)    nebula: 0 0 0 0 0 1 1 0
      
           

   .. method:: proc init(W: [], name: string)

      
      :arg W: matrix of reals
      :rtype: Graph
       

   .. method:: proc init(W: [], directed: bool)

      
      In an undirected graph, the lower tri is populated from the upper tri, so given
      values on the lower tri are ignored
       

   .. method:: proc init(W: [], directed = bool, name: string, vnames: [])

.. method:: proc Graph.loadW(W: [])

   
   

.. method:: proc Graph.addEdge(fromId: int, toId: int, w: real)

   
   Creates an edge between vertices fromId and toId, adds both entries
   if graph is not directed
   
   :arg fromId: vertex id for the tail vertex
   :arg toId: vertex id for the head vertex
   :arg w: Weight of the edges
   

.. method:: proc Graph.addEdge(fromId: int, toId: int)

   
   Adds an edge and sets the weight to 1.0
    

.. method:: proc Graph.updateEdge(fromId: int, toId: int, w: real)

   
   Adds w to the edge between fromId and toId, also the reverse if not directed.
   If the edge does not exist, it is added with weight w.
   
    

.. method:: proc Graph.neighbors(vid: int)

   
   returns an array of vertex ids (row/col numbers) for a given vertex id
   
   ::
   
       for n in g3.neighbors(1).sorted() {
         writeln("neighbor of 1: ", n, ": ", g3.nameIndex[n]);
       }
       >>
       neighbor of 1: 2: gamora
       neighbor of 1: 3: groot
       neighbor of 1: 4: drax
   
   :rtype: int []

.. method:: proc Graph.neighbors(vname: string)

   
     Returns an array of vertex ids (row/col numbers) for a given vertex name.
   
   example::
   
     for n in g3.neighbors("star lord").sorted() {
       writeln("neighbor of 1: ", n, ": ", g3.nameIndex[n]);
     }
     >>
     neighbor of 1: 2: gamora
     neighbor of 1: 3: groot
     neighbor of 1: 4: drax
      

.. method:: proc Graph.boundary(vs: domain(int))

   
   Looks for the boundary of a subgraph in G and returns an integer domain of vertex ids.
   
   :returns: a set of vertex ids not in `vs` but having an edge to a vertex in `vs`
   :rtype: domain(int)
   
    

.. method:: proc Graph.degree()

   
      returns: Array of degrees for each vertex.  This the count of edges, not the sum of weights.
   
   :rtype: int []
      

.. method:: proc Graph.degree(v: int)

   
   Returns the number of edges adjacent to vertex `v`
   
   :arg v: integer
   
   :rtype: int []
   

.. method:: proc Graph.flow()

   
     Returns the Adjacency matrix A * 1 to give the total sum of weights, indicating the flow
     around the vertex
   
   :rtype: real []
      

.. method:: proc Graph.flow(vs: domain(int))

   
     Returns the sum of the incident weights on an "interior" set of vertices.  Calculation is to take
     a vector of ones[interior] and do W.dot(o)
   
     Calls flow(vs, interior=false)
   
   :rtype: real []
      

.. method:: proc Graph.flow(vs: domain(int), interior: bool)

   
   By default, this calculates the sum of the weights for all vertices with edges against the vertices
   in the subgraph :param:`vs`.  The return is an array with length nodes(G) with the value of the flow in
   each element.  If 'interior=true' then the elements outside `vs` are zeroed out.
   
   :arg vs: Array of vertex ids to calculate
   :arg interior: Bool to indicate if weights should be restricted to vertices in :param:`vs`
   
   :returns: Sum of the weights adjacent to vertex set ``vs`` given subgraph ``interior``
   :rtype: int []
     

.. method:: proc Graph.flow(vs: domain(string), interior: bool)

   
     By default, this calculates the sum of the weights for all vertices with edges against the vertices
     in the subgraph :param:`vs`.
   
   :arg vs: Array of vertex names to calculate
   :arg interior: Bool to indicate if weights should be restricted to vertices in :param:`vs`
   
   :returns: Sum of the weights adjacent to vertex set ``vs`` given subgraph ``interior``
   :rtype: int []
   
      

.. method:: proc Graph.subgraphEntropy(subgraph: domain(int), base: [])

   
   The vertexEntropy calculates the ratio of edge strength to the interior and exterior of a given subgraph
   
   :arg interior: A set of vertex string names representing a sub-graph.
   :arg base: An array of degrees for the whole graph, should be called by :proc:`Graph.flow()` beforehand
    

.. function:: proc buildGraphFromPGTables(con: Connection, nameTable: string, nameField: string, idField: string, edgeTable: string, toField: string, fromField: string, wField: string, directed: bool, graphName: string, weights = true)

   
   Builds a Graph object using `NumSuch <https://github.com/buddha314/numsuch>`_ MatrixOps module
   
   :arg nameTable: The name of the Postgres table containing the pairs
   :arg nameField: The name of the field in the nameTable containing the names
   :arg idField: The name of the field in the nameTable containing the feature ids
   :arg con: A CDO Connection to Postgres
   :arg edgeTable: The table in PG of edges
   :arg fromField: The field of edgeTable containing the id of the head vertex
   :arg toField: the field of edgeTable containing the id of the tail vertex
   :arg wField: The field of edgeTable containing the weight of the edge
   :arg directed: Boolean indicating whether graph is directed
   :arg graphName: A name for the graph
   :arg weights: Boolean on whether to use the weights in the table or a 1 (indicator)
   
   

.. class:: Crystal

   
   A class to hold sub-graphs.  The language is not standard but convenient.  A "crystal" is
   essentially a sub-graph.  During the "tempering" process, vertices will be added and removed
   until a minimum entropy is accomplished.  The initial vertex Ids are held in :const:`ftrIds`.  The
   derived minimum entropy is in :var:`minEntropy` and the final vertex ids are in
   


   .. attribute:: const id: string

   .. attribute:: var ftrIds: domain(int)

   .. attribute:: var initialEntropy: real

   .. attribute:: var minEntropy: real

   .. attribute:: var minFtrs: domain(int)

   .. method:: proc init(id: string, ftrIds: [])

      
      Constructor
      
      :arg id: Any string identifier for this crystal.
      :arg ftrIds: The set of vertex ids that compose the untempered crystal stored as ``domain(int)``
       

.. function:: proc buildCrystalsFromPG(con: Connection, constituentTable: string, idField: string, constituentIdField: string)

   
   Creates a set of untempered crystals from a Postgres table.
   Requires data within Postgres as in test/data/entropy_base_graph_schema.sql
   
   :arg constituentTable: Postgres table with the crystal and their constituent ids
   :arg constituentIdField: The field in the constituentTable with the constituent id
   :arg idField: The field in the constituentTable that has the crystal id
   
   :returns: An array of crystals from a given Postgres table
   :rtype: :class:`Crystal`
    

