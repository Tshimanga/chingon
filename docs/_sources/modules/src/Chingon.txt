.. default-domain:: chpl

.. module:: Chingon
   :synopsis: Documentation for Chingon v 0.1.1

Chingon
=======
**Usage**

.. code-block:: chapel

   use Chingon;


Documentation for Chingon v 0.1.1
=================================

Much of this library is motivated by the book `Graph Algorithms in the Language of Linear Algebra by Kepner and Gilbert <http://bookstore.siam.org/se22/>`_

Some basic definitions.  We are attempting to operate according to general standards.  Since some of
the literature is inconsistent, we define some important concepts here.

*  A: The Adjacency matrix, A(i,j) is the weight between vertices i and j.  A(i,i) = 0.
   In the case of directed matrices, the edge represents the weight or indicator of i to j.
*  W: The weight matrix, W(i,j) is the weight between vertices i and j and may have non-zero diagonal
*  Laplacian Matrix L = D - A for simple graphs: https://en.wikipedia.org/wiki/Laplacian_matrix#Laplacian_matrix_for_simple_graphs


.. class:: Graph

   
   A Graph object is a (sparse) matrix with some meta-data attached to it.  The underlying
   matrix
   


   .. attribute:: var vdom: domain(2)

   .. attribute:: var SD: vdom.defaultSparseDistchpl__buildSparseDomainRuntimeTypevdom dmapped CS(compressRows = true)

   .. attribute:: var W: [SD] real

   .. attribute:: var name: string

   .. attribute:: var vnames: domain(string)

   .. attribute:: var vids: [vnames] int

   .. attribute:: var nameIndex: [1..0] string

   .. method:: proc init(M: [])

   .. method:: proc init(M: [], name: string)

   .. method:: proc init(M: [], name: string, vnames: [])

      
      Example object initialization::
      
        var nv: int = 8,
            D: domain(2) = {1..nv, 1..nv},
            SD: sparse subdomain(D),
            M: [SD] real;
      
        SD += (1,2); M[1,2] = 1;
        SD += (1,3); M[1,3] = 1;
        SD += (1,4); M[1,4] = 1;
        SD += (2,4); M[2,4] = 1;
        SD += (3,4); M[3,4] = 1;
        SD += (4,5); M[4,5] = 1;
        SD += (5,6); M[5,6] = 1;
        SD += (6,7); M[6,7] = 1;
        SD += (6,8); M[6,8] = 1;
        SD += (7,8); M[7,8] = 1;
        var g3 = new Graph(M=M, name="Vato", vnames = vn);
      
           

.. itermethod:: iter Graph.nbs(vid: int)

   
   Internal iterator to get vertex ids that are neighbors of "vid"
   :arg vid: A vertex id
   :type vid: int
   
   :rtype: iterator
   
   TODO: Make sure the diagonal is removed.
      

.. method:: proc Graph.neighbors(vid: int)

   
   returns an array of vertex ids (row/col numbers) for a given vertex id
   
   well, I don't know about that::
   
       for n in g3.neighbors(1).sorted() {
         writeln("neighbor of 1: ", n, ": ", g3.nameIndex[n]);
       }
       >>
       neighbor of 1: 2: gamora
       neighbor of 1: 3: groot
       neighbor of 1: 4: drax

.. method:: proc Graph.neighbors(vname: string)

   
     Returns an array of vertex ids (row/col numbers) for a given vertex name.
   
   example::
   
     for n in g3.neighbors("star lord").sorted() {
       writeln("neighbor of 1: ", n, ": ", g3.nameIndex[n]);
     }
     >>
     neighbor of 1: 2: gamora
     neighbor of 1: 3: groot
     neighbor of 1: 4: drax
      

.. method:: proc Graph.degree()

   
   returns: Array of degrees for each vertex.  This the count of edges, not the sum of weights.
   rtype: int []
   

.. method:: proc Graph.weights()

   
   Returns the Adjacency matrix A * 1 to give the total sum of weights
   :rtype: real []
    

.. method:: proc Graph.vertexEntropy(interior: domain, vertex: int)

   
   The vertexEntropy calculates the ratio of edge strength to the interior and exterior of a given subgraph
   
   
   :arg interior: A set of vertex string names representing a sub-graph.
    

