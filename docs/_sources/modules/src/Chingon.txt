.. default-domain:: chpl

.. module:: Chingon
   :synopsis: Documentation for Chingon v 0.1.1

Chingon
=======
**Usage**

.. code-block:: chapel

   use Chingon;


Documentation for Chingon v 0.1.1
=================================

Much of this library is motivated by the book `Graph Algorithms in the Language of Linear Algebra by Kepner and Gilbert <http://bookstore.siam.org/se22/>`_

Some basic definitions.  We are attempting to operate according to general standards.  Since some of
the literature is inconsistent, we define some important concepts here.

*  A: The Adjacency matrix, A(i,j) is the weight between vertices i and j.  A(i,i) = 0.
   In the case of directed matrices, the edge represents the weight or indicator of i to j.
*  W: The weight matrix, W(i,j) is the weight between vertices i and j and may have non-zero diagonal
*  Laplacian Matrix L = D - A for simple graphs: https://en.wikipedia.org/wiki/Laplacian_matrix#Laplacian_matrix_for_simple_graphs


.. class:: Graph

   
   A Graph object is a (sparse) matrix with some meta-data attached to it.  The underlying
   matrix
   


   .. attribute:: var vdom: domain(2)

   .. attribute:: var SD: vdom.defaultSparseDistchpl__buildSparseDomainRuntimeTypevdom dmapped CS(compressRows = true)

   .. attribute:: var W: [SD] real

   .. attribute:: var name: string

   .. attribute:: var vnames: domain(string)

   .. attribute:: var vids: [vnames] int

   .. attribute:: var nameIndex: [1..0] string

   .. attribute:: var directed: bool = false

   .. method:: proc init(W: [])

      
      Example object initialization::
      
        var nv: int = 8,
            D: domain(2) = {1..nv, 1..nv},
            SD: sparse subdomain(D),
            M: [SD] real;
      
          SD += (1,2); W[1,2] = 1;
          SD += (1,3); W[1,3] = 1;
          SD += (1,4); W[1,4] = 1;
          SD += (2,2); W[2,2] = 1;
          SD += (2,4); W[2,4] = 1;
          SD += (3,4); W[3,4] = 1;
          SD += (4,5); W[4,5] = 1;
          SD += (5,6); W[5,6] = 1;
          SD += (6,7); W[6,7] = 1;
          SD += (6,8); W[6,8] = 1;
          SD += (7,8); W[7,8] = 1;
        var g3 = new Graph(M=M, name="Vato", vnames = vn);
      
         In ascii, the graph is
      
      ::
      
        (3)--(1)--(2)> (a loop)
         |    |    |
         |    |    |
         ----(4)----
              |
              |--(5)--(6)--(7)--(8)  // TURN TURN KICK TURN!  Bob Fosse Lives!
                       |---------|
      
      The Weighted Matrix (assuming undirected) is thus
      
      ::
      
        1) star lord: 0 1 1 1 0 0 0 0
        2)    gamora: 0 1 0 1 0 0 0 0
        3)     groot: 0 0 0 1 0 0 0 0
        4)      drax: 0 0 0 0 1 0 0 0
        5)    rocket: 0 0 0 0 0 1 0 0
        6)    mantis: 0 0 0 0 0 0 1 1
        7)     yondu: 0 0 0 0 0 0 0 1
        8)    nebula: 0 0 0 0 0 0 0 0
      
      With symmetric version
      
      ::
      
        1) star lord: 0 1 1 1 0 0 0 0
        2)    gamora: 1 1 0 1 0 0 0 0
        3)     groot: 1 0 0 1 0 0 0 0
        4)      drax: 1 1 1 0 1 0 0 0
        5)    rocket: 0 0 0 1 0 1 0 0
        6)    mantis: 0 0 0 0 1 0 1 1
        7)     yondu: 0 0 0 0 0 1 0 1
        8)    nebula: 0 0 0 0 0 1 1 0
      
           

   .. method:: proc init(W: [], name: string)

      
      :arg W: matrix of reals
      :rtype: Graph
       

   .. method:: proc init(W: [], directed: bool)

      
      In an undirected graph, the lower tri is populated from the upper tri, so given
      values on the lower tri are ignored
       

   .. method:: proc init(W: [], directed = bool, name: string, vnames: [])

.. method:: proc Graph.loadW(W: [])

.. itermethod:: iter Graph.nbs(vid: int)

   
   Internal iterator to get vertex ids that are neighbors of "vid"
   :arg vid: A vertex id
   :type vid: int
   
   :rtype: iterator
   
      

.. method:: proc Graph.neighbors(vid: int)

   
   returns an array of vertex ids (row/col numbers) for a given vertex id
   
   well, I don't know about that::
   
       for n in g3.neighbors(1).sorted() {
         writeln("neighbor of 1: ", n, ": ", g3.nameIndex[n]);
       }
       >>
       neighbor of 1: 2: gamora
       neighbor of 1: 3: groot
       neighbor of 1: 4: drax

.. method:: proc Graph.neighbors(vname: string)

   
     Returns an array of vertex ids (row/col numbers) for a given vertex name.
   
   example::
   
     for n in g3.neighbors("star lord").sorted() {
       writeln("neighbor of 1: ", n, ": ", g3.nameIndex[n]);
     }
     >>
     neighbor of 1: 2: gamora
     neighbor of 1: 3: groot
     neighbor of 1: 4: drax
      

.. method:: proc Graph.degree()

   
   returns: Array of degrees for each vertex.  This the count of edges, not the sum of weights.
   rtype: int []
   

.. method:: proc Graph.weights()

   
   Returns the Adjacency matrix A * 1 to give the total sum of weights
   :TODO: Merge this with the routine below to as to not duplicate code.
   :rtype: real []
    

.. method:: proc Graph.weights(interior: [])

   
   Returns the sum of the incident weights on an "interior" set of vertices.  Calculation is to take
   a vector of ones[interior] and do o^T.dot(W^T)
   
   :rtype: real []
    

.. method:: proc Graph.vertexEntropy(interior: domain, vertex: int)

   
   The vertexEntropy calculates the ratio of edge strength to the interior and exterior of a given subgraph
   
   
   :arg interior: A set of vertex string names representing a sub-graph.
    

